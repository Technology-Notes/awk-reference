:toc:
:toc-placement!:

# AWK Reference

toc::[]

# Program structure

[source,bash]
----
   BEGIN {}       # executed once
   /pattern/ { }  # executed for each line matching pattern
   END {}         # executed once
----


# Pattern matching

[source,bash]
----
    echo '1

    test' | awk '
        /[0-9]+/ { print "That is an integer" }
        /[A-Za-z]+/ { print "This is a string" }
        /^$/ { print "This is a blank line." }
        { print }
    '

    This is a blank line.

    That is an integer
    1
    This is a blank line.

    This is a string
----

We can match the specific field:

[source,bash]
----
   echo '1 test description
         2 script description' | awk '
   $2 ~ /script/ { print $1 ", " $3 }'

   2, description
----

Reverse the meaning of the rule by using bang-tilde (!~): `$2 !~ /script/`.

[source,bash]
----
   echo '1 test description
         2 script description' | awk '
   $2 !~ /script/ { print $1 ", " $3 }'

   1, description
----

It is possible to use comparison operators too, for example `NF == 6 { print $1, $6 }` will make sure that we have 6 fields before printing them:

[source,bash]
----
   echo '1 2 3 4 5 6
         1 2 3
         1 2 3 4 5' | awk '
   NF == 6 { print $1, $6 }'

   1, 6
----

More complex expressions can be used as well, for example `NR > 1 && (NF >= 2 || $1  ̃ /\t/)`.

# Fields

    $0 - the whole record (line)
    $1, $2, ... - fields

Example:

[source,bash]
----
    echo a b c d | awk '{ print $1 $2 }'

    ab
----

Any expression that evaluates to integer can be used as field number, the following outputs `c`:

[source,bash]
----
    echo a b c d | awk 'BEGIN { one = 1; two = 2 }
    { print $(one + two) }'

    c
----

Default field separator is space, can be changed with command line flag `awk -F:`(':' as separator),
or `awk -F"\t" ...` to use tab as a separator.

Can also be changed inside the script by setting `FS` variable:

[source,bash]
----
    echo a,b,c,d | awk 'BEGIN { FS="," }
    { print $2 }'

    b
----

Field separator can be an expression:

[source,bash]
----
    echo a_b:c d | awk 'BEGIN { FS="[_: ]" }
    { print $1 "-" $2 "-" $3 "-" $4}'

    a-b-c-d
----

# Expressions

There are two types of constants: string or numeric ("red" or 1).
A string must be quoted in an expression.

Strings can make use of the escape sequences:
    \a Alert character, usually ASCII BEL character
    \b Backspace
    \f Formfeed
    \n Newline
    \r Carriage return
    \t Horizontal tab
    \v Vertical tab
    \ddd Character repr esented as 1 to 3 digit octal value
    \xhex Character repr esented as hexadecimal value a
    \c Any literal character c (e.g., \" for ") b

[source,bash]
----
    echo a_b:c d | awk 'BEGIN { FS="[_: ]" }
    { print $1 "\v" $2 "\t" $3 "\"" $4}'

    a
     b      c"d
----

Variables:
- name = value
- name is case sensitive
- default value is zero
- each variable has string and integer value
  - strings that are not numbers evaluate to zero

A space is the string concatenation operator:

    z = "Hello" "World"

assigns “HelloWorld” to the variable z.

There are +/-, etc arithmetic operators.
There are +=, -=, ++ (both postfix and infix), -- assignment operators.

[source,bash]
----
    echo '1

    2' | awk '
    # Count blank lines.
    /^$/ {
        ++x  # Default value is 0, so we don't initialize x, just start incrementing
    }
    END {
        print x
    }'

    1
----

Average calculation:

[source,bash]
----
    echo 'john 85 92 78 94 88
    andrea 89 90 75 90 86
    jasper 84 88 80 92 84' | awk '
    # average five grades
    { total = $2 + $3 + $4 + $5 + $6
    avg = total / 5
    print $1, avg }'

    john 87.4
    andrea 86
    jasper 85.6
----

# System variables

* `FS` - input field separator (space by default)
** Note: usually FS is assigned in the BEGIN block, but can be changed anywhere
   new FS value will take effect on the next line (not on the current line)
* `OFS` - output field separator (space by default)
* `NF` - number of fields (so `{ print $NF }` outputs last field)
** Note: NF is mutable, can be changed (as well as $0 or fields)
* `RS` - record separator, default is newline
* `ORS` - output record separator
* `NR` - current record number
* `FILENAME` - current file name
* `FNR` - current record number in current file (useful when there are many files)
* `CONVFMT` - `printf`-style number-to-string conversion format, "%.6g" by default
** Used when we do `str = (5.5 + 3.2) " is a nice value"`
* `OFMT` - `printf` style number-to-string conversion when number is printed
** Used when we do `print 5.5`

Average calculation with auto-numbering:

[source,bash]
----
echo 'john 85 92 78 94 88
andrea 89 90 75 90 86
jasper 84 88 80 92 84' | awk '
# We will have tabs as output fields separator.
BEGIN { OFS = "\t" }
# average five grades
{ total = $2 + $3 + $4 + $5 + $6
avg = total / 5
print NR ".", $1, avg }
END {
print ""
print NR, "records processed." }'

1.      john    87.4
2.      andrea  86
3.      jasper  85.6

3       records processed.
----

# Processing multiline records:

[source,bash]
----
echo 'John Robinson
Boston MA 01760

Phyllis Chapman
Amesbury MA 01881' | awk '
# set field separator to a newline and record separator to the empty string
BEGIN { FS = "\n"; RS = "" }
{ print $1, $NF}'

John Robinson Boston MA 01760
Phyllis Chapman Amesbury MA 01881
----

Also split the output to multiple lines:

[source,bash]
----
echo 'John Robinson
Boston MA 01760

Phyllis Chapman
Amesbury MA 01881' | awk '
# set field separator to a newline and record separator to the empty string
BEGIN { FS = "\n"; RS = ""; OFS = "\n"; ORS = "\n\n" }
{ print $1, $NF}'

John Robinson
Boston MA 01760

Phyllis Chapman
Amesbury MA 01881
----

# Special processing based on row number and using `next` and `exit`

We can use expression like `NR == 1` to apply special rule for the first record.
Inside that rule we can use `next` to skip following rules:


[source,bash]
----
echo '1000
125	 Market	 -125.45
126	 Hardware Store	 -34.95156' | awk '
BEGIN { FS="\t" }

# First line is the initial balance.
NR == 1 {
    balance=$1;
    print "Initial balance: ", balance;
    next  # get the next record and start over (do not proceed with next rule)
}
# Update balance.
{ balance += $3 }
# Show the result.
END { print "Final balance: ", balance }'

Initial balance:  1000
Final balance:  839.598
----

The `next` statement causes the next line to be read and resumes execution from the top of the script.

The `exit` statement exits the main loop and passes control to `END` section (stops execution if used in `END` of if there is no `END` section).
The `exit` takes an expression as an argument. It will be used as script exit status code, by default exit status is 0.

Similar example with interesting trick to remove header and footer (source: https://stackoverflow.com/a/7148801/4612064).
Here we extract a list of file names from the `7z l` output which looks like this:


[source,bash]
----
7-Zip [64] 9.20  Copyright (c) 1999-2010 Igor Pavlov  2010-11-18
p7zip Version 9.20 (locale=en_US.UTF-8,Utf16=on,HugeFiles=on,4 CPUs)

Listing archive: output/folder/7z_1.7z

--
Path = output/folder/7z_1.7z
Type = 7z
Solid = -
Blocks = 0
Physical Size = 141
Headers Size = 141

   Date      Time    Attr         Size   Compressed  Name
------------------- ----- ------------ ------------  ------------------------
2017-11-10 17:33:18 ....A            0            0  (E).txt
2017-11-10 17:33:18 ....A            0            0  (J) [!].txt
2017-11-10 17:33:18 ....A            0            0  (J).txt
2017-11-10 17:33:18 ....A            0            0  (U) [!].txt
2017-11-10 17:33:18 ....A            0            0  (U).txt
------------------- ----- ------------ ------------  ------------------------
                                     0            0  5 files, 0 folders
----

And the `awk` script to get only file names:

[source,bash]
----
/----/ {p = ++p % 2; print "p: ", p; next}
$NF == "Name" {pos = index($0,"Name")}
p {print p, substr($0,pos)}
----

Initially `p` is zero, so the last rule with `print` doesn't work.
Second line cacluates the position where the file name starts (by checking the position of "Name" in the header.
Once we meet first "----", the `p` value becomes 1 (1 % 2 = 1) and we start processing filenames.
And when we get to the next "----", the `p` value becomes 0 (2 % 2 = 0) and we stop the processing.

# Formatting output: printf

Syntax:

  printf ( format-expression [, arguments] )

The parentheses are optional.

Format specifiers:

- c ASCII character
- d Decimal integer
- i Decimal integer. (Added in POSIX)
- e Floating-point format ([-]d.pr ecisione[+-]dd)
- E Floating-point format ([-]d.pr ecisionE[+-]dd)
- f Floating-point format ([-]ddd.pr ecision)
- g e or f conversion, whichever is shortest, with trailing zeros removed
- G E or f conversion, whichever is shortest, with trailing zeros removed
- o Unsigned octal value
- s String
- u Unsigned decimal value
- x Unsigned hexadecimal number. Uses a-f for 10 to 15
- X Unsigned hexadecimal number. Uses A-F for 10 to 15
- % Literal %

A format expression can take three optional modifiers following “%” and preceding the format specifier:

  %-width.precision format-specifier

* width - numeric value, the contents will be right-justified, use '-' to get left-justification.
** `echo '5' | awk '{ printf("*%20s*", $1) }'` -> `*                   5*`
** `echo '5' | awk '{ printf("*%-20s*", $1) }'` -> `*5                   *`
* precision:
** for decimal or floating-point values - the number of digits to the right of the decimal point;
** for string values - the maximum number of characters that will be printed.

[source,bash]
----
echo '3.1415' | awk '{ printf("%.3g", $1) }'

3.14
----

Default format: `%.6g`.

With and precision can be specified dynamically:

[source,bash]
----
echo '3.1415' | awk '{ printf("%*.*g", 5, 3, $1) }'

 3.14
----

# Passing Parameters Into a Script

Variables can be passed using `var=value` parameters:

   awk ’script’ var=value inputfile

For example:

   $ awk -f scriptfile high=100 low=60 datafile

   # Use env variable as value:
   $ awk ’{ ... }’ directory=$cwd file1 ...

   # Use `pwd` output as value:
   $ awk ’{ ... }’ directory=‘pwd‘ file1 ...

It is possible to use command-line parameters to define system variables:

   $ awk ’{ print NR, $0 }’ OFS=’. ’ names

Note: command-line parameters is that they are not available in the BEGIN procedure.
BEGIN is evaluated before the input is read.

[source,bash]
----
awk 'BEGIN {
  # Here `n` is not set.
  print "Begin: " n
}
{
  # Will print "Reading the first file" for each line in `test` file.
  if (n == 1) print "Reading the first file"
  # Will print "Reading the second file" for each line in `test2` file.
  if (n == 2) print "Reading the second file"
}' n=1 test n=2 test2
----

The `-v` options allows to specify parameters that are evaluated early and available in BEGIN:

[source,bash]
----
# The -v option must be specified before the script itself.
awk -v n=1 'BEGIN {
  # prints "Begin: 1"
  print "Begin: " n
}'
----

The `-v` option can be used for system variables too (here we set `RS`): `awk -F"\n" -v RS="" '{ print }' ...`.

[source,bash]
----
echo 'test
test

test2
test2' | awk -F"\n" -v RS="" -v n=1 '{
    # We use new line as filed separator and
    # empty line as record separator
    print n, $1, "-", $2
}'

1 test - test
1 test2 - test2
----

Awk also provides the system variables `ARGC` and `ARGV`, similar to C.

# Conditional Statements

    if ( expression )
      action1
    [else
      action2 ]

    if ( expression ) action1 ; [else action2 ]

    if (avg >= 90) grade = "A"
    else if (avg >= 80) grade = "B"
    else if (avg >= 70) grade = "C"
    else if (avg >= 60) grade = "D"
    else grade = "F"

Conditional operator:

    expr ? action1 : action2

    grade = (avg >= 65) ? "Pass" : "Fail"

# Looping

    # While loop
    while ( condition )
      action

    i = 1
    while ( i <= 4 ) {
      print $i
      ++i
    }

    # Do loop
    do
      action
    while ( condition )

    do {
      ++x
      print x
    } while ( x <= 4 )

    # For loop
    for ( set_counter ; test_counter ; increment_counter )
      action

    for ( i = 1; i <= NF; i++ )
      print $i

Prompt the user for a number and calculate factorial:

[source,bash]
----
awk '# factorial: return factorial of user-supplied number
  BEGIN {
    # prompt user; use printf, not print, to avoid the newline
    printf("Enter number: ")
  }
  # check that user enters a number
  $1 ~ /^[0-9]+$/ {
    # assign value of $1 to number & fact
    number = $1
    if (number == 0)
      fact = 1
    else
      fact = number
    # loop to multiply fact*x until x = 1
    for (x = number - 1; x > 1; x--)
      fact *= x
    printf("The factorial of %d is %g\n", number, fact)
    # exit -- saves user from typing CRTL-D.
    exit
  }
  # if not a number, prompt again.
  { printf(" \nInvalid entry. Enter a number: ")
}' -
----

Loops support `break` (exit the loop) and `continue` (start the next iteration).
