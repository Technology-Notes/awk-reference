:toc:
:toc-placement!:

# AWK Reference

toc::[]

# Program structure

[source,bash]
----
   BEGIN {}       # executed once
   /pattern/ { }  # executed for each line matching pattern
   END {}         # executed once
----


# Pattern matching

[source,bash]
----
    echo '1

    test' | awk '
        /[0-9]+/ { print "That is an integer" }
        /[A-Za-z]+/ { print "This is a string" }
        /^$/ { print "This is a blank line." }
        { print }
    '

    This is a blank line.

    That is an integer
    1
    This is a blank line.

    This is a string
----

We can match the specific field:

[source,bash]
----
   echo '1 test description
         2 script description' | awk '
   $2 ~ /script/ { print $1 ", " $3 }'

   2, description
----

Reverse the meaning of the rule by using bang-tilde (!~): `$2 !~ /script/`.

# Fields

    $0 - the whole record (line)
    $1, $2, ... - fields

Example:

[source,bash]
----
    echo a b c d | awk '{ print $1 $2 }'

    ab
----

Any expression that evaluates to integer can be used as field number, the following outputs `c`:

[source,bash]
----
    echo a b c d | awk 'BEGIN { one = 1; two = 2 }
    { print $(one + two) }'

    c
----

Default field separator is space, can be changed with command line flag `awk -F:`(':' as separator),
or `awk -F"\t" ...` to use tab as a separator.

Can also be changed inside the script by setting `FS` variable:

[source,bash]
----
    echo a,b,c,d | awk 'BEGIN { FS="," }
    { print $2 }'

    b
----

Field separator can be an expression:

[source,bash]
----
    echo a_b:c d | awk 'BEGIN { FS="[_: ]" }
    { print $1 "-" $2 "-" $3 "-" $4}'

    a-b-c-d
----

# Expressions

There are two types of constants: string or numeric ("red" or 1).
A string must be quoted in an expression. 

Strings can make use of the escape sequences:
    \a Alert character, usually ASCII BEL character
    \b Backspace
    \f Formfeed
    \n Newline
    \r Carriage return
    \t Horizontal tab
    \v Vertical tab
    \ddd Character repr esented as 1 to 3 digit octal value
    \xhex Character repr esented as hexadecimal value a
    \c Any literal character c (e.g., \" for ") b

[source,bash]
----
    echo a_b:c d | awk 'BEGIN { FS="[_: ]" }
    { print $1 "\v" $2 "\t" $3 "\"" $4}'

    a
     b      c"d
----

Variables:
- name = value
- name is case sensitive
- default value is zero
- each variable has string and integer value
  - strings that are not numbers evaluate to zero

A space is the string concatenation operator:

    z = "Hello" "World"

assigns “HelloWorld” to the variable z.

There are +/-, etc arithmetic operators.
There are +=, -=, ++ (both postfix and infix), -- assignment operators.

[source,bash]
----
    echo '1

    2' | awk '
    # Count blank lines.
    /^$/ {
        ++x  # Default value is 0, so we don't initialize x, just start incrementing
    }
    END {
        print x
    }'

    1
----

Average calculation:

[source,bash]
----
    echo 'john 85 92 78 94 88
    andrea 89 90 75 90 86
    jasper 84 88 80 92 84' | awk '
    # average five grades
    { total = $2 + $3 + $4 + $5 + $6
    avg = total / 5
    print $1, avg }'

    john 87.4
    andrea 86
    jasper 85.6
----

# System variables

* `FS` - input field separator (space by default)
** Note: usually FS is assigned in the BEGIN block, but can be changed anywhere
   new FS value will take effect on the next line (not on the current line)
* `OFS` - output field separator (space by default)
* `NF` - number of fields (so `{ print $NF }` outputs last field)
** Note: NF is mutable, can be changed (as well as $0 or fields)
* `RS` - record separator, default is newline
* `ORS` - output record separator
* `NR` - current record number
* `FILENAME` - current file name
* `FNR` - current record number in current file (useful when there are many files)
* `CONVFMT` - `printf`-style number-to-string conversion format, "%.6g" by default
** Used when we do `str = (5.5 + 3.2) " is a nice value"`
* `OFMT` - `printf` style number-to-string conversion when number is printed
** Used when we do `print 5.5`

Average calculation with auto-numbering:

[source,bash]
----
echo 'john 85 92 78 94 88
andrea 89 90 75 90 86
jasper 84 88 80 92 84' | awk '
# We will have tabs as output fields separator.
BEGIN { OFS = "\t" }
# average five grades
{ total = $2 + $3 + $4 + $5 + $6
avg = total / 5
print NR ".", $1, avg }
END {
print ""
print NR, "records processed." }'

1.      john    87.4
2.      andrea  86
3.      jasper  85.6

3       records processed.
----

Multiline records:

[source,bash]
----
echo 'John Robinson
Boston MA 01760

Phyllis Chapman
Amesbury MA 01881' | awk '
# set field separator to a newline and record separator to the empty string
BEGIN { FS = "\n"; RS = "" }
{ print $1, $NF}'

John Robinson Boston MA 01760
Phyllis Chapman Amesbury MA 01881
----

Also split the output to multiple lines:

[source,bash]
----
echo 'John Robinson
Boston MA 01760

Phyllis Chapman
Amesbury MA 01881' | awk '
# set field separator to a newline and record separator to the empty string
BEGIN { FS = "\n"; RS = ""; OFS = "\n"; ORS = "\n\n" }
{ print $1, $NF}'

John Robinson
Boston MA 01760

Phyllis Chapman
Amesbury MA 01881
----
